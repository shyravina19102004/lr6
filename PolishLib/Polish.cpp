#include "../PolishLib/Polish.h"

TNum::TNum(int _d) //устанавливает значение переменной data равным значению аргумента _d
{
    data = _d;
}

TNum::TNum(TNum& _d) //конструктор должен принимать аргумент типа TNum по константной ссылке (const TNum& _d), чтобы избежать ненужного копирования объекта
{
    data = _d.data;
}

TNum::TNum(char* s) //принимает строку и преобразует ее в числовое значение, которое сохраняется в переменной data
//Метод проходит по строке до тех пор, пока встречает цифру (используя функцию isdigit), 
//а затем использует функцию atof для преобразования подстроки начиная с этой цифры в числовое значение float. 
//Если строка не заканчивается после числа, то возникает исключение std::exception
{
    int i = 0;
    while (isdigit(s[i]))
        i++;
    if (s[i] != 0)
        throw std::exception();
    data = atof(s);
}

int TNum::prioritet() //возвращает значение -1
{
    return -1; 
}

int TNum::getNumber() //возвращает числовое значение, которое было присвоено переменной data в конструкторе TNum::TNum(char* s)
{
    return data;
}

Lexem* TNum::Calc(Lexem* a, Lexem* b) //должен выдавать ошибку при вызове
{
    throw - 1;
}

TOper::TOper(TOper& _d) //копирует данные из другого объекта класса TOper
{
    data = _d.data;
}

TOper::TOper(char s) //принимает символ и сохраняет его в переменной данных
{
    data = s;
}

int TOper::getNumber() //выдавать ошибку при вызове
{
    throw - 1;
}

int TPlus::prioritet() //возвращает значение 2, что обозначает приоритет операций сложения 
{
    return 2;
}

Lexem* TPlus::Calc(Lexem* a, Lexem* b) //выполняет операции сложения и возвращает результат в виде объекта класса TNum
{
    TNum* res = new TNum(a->getNumber() + b->getNumber());
    return res;
}

int TSub::prioritet() //вычитание
{
    return 2;
}

Lexem* TSub::Calc(Lexem* a, Lexem* b)
{
    TNum* res = new TNum(a->getNumber() - b->getNumber());
    return res;
}

int TMultiplication::prioritet() //операцию умножения
//Метод prioritet() возвращает значение 3, показывая, что операция умножения имеет более высокий приоритет, чем операции сложения и вычитания.
{
    return 3;
}

Lexem* TMultiplication::Calc(Lexem* a, Lexem* b) ////Метод Calc() выполняет операцию умножения между двумя операндами, представленными объектами класса Lexem, 
//и возвращает результат в виде объекта класса TNum, представляющего числовой результат умножения
{
    TNum* res = new TNum(a->getNumber() * b->getNumber());
    return res;
}

int TDivision::prioritet() //возвращает значение 3. деление
{
    return 3;
}

Lexem* TDivision::Calc(Lexem* a, Lexem* b) // Метод Calc() выполняет операцию деления между двумя операндами, представленными объектами класса Lexem.
//Он также проверяет, что второй операнд не равен нулю, и если это так, то выбрасывает исключение типа int со значением -1
{
    if (b->getNumber() == 0)
        throw - 1;
    TNum* res = new TNum(a->getNumber() / b->getNumber());
    return res;
}

int TBracketOpen::prioritet() //возвращает значение 1, что указывает на самый низкий приоритет в математическом выражении
{
    return 1;
}

Lexem* TBracketOpen::Calc(Lexem* a, Lexem* b) //Метод Calc() выбрасывает исключение типа int со значением -1
{
    throw - 1;
}

int TBracketClose::prioritet() //возвращает значение приоритета операции
{
    return 0;
}

Lexem* TBracketClose::Calc(Lexem* a, Lexem* b) //выкидывает исключение, когда он вызывается для операции закрывающей скобки, потому что для операции закрывающей скобки не требуется выполнения каких-либо вычислений
{
    throw - 1;
}

void TOperFactory::create(char* s, int& n, Lexem**& opers) //Код создает массив объектов класса Lexem, основанный на символьном массиве s.

{
    int l = strlen(s);
    n = 0; //Переменная n обновляется для хранения количества элементов массива res.
    for (int i = 0; i < l; i++) { //ри каждом обходе цикла for, если символ в позиции i не является цифрой, значение n увеличивается на 1.
        if (isdigit(s[i]) == 0)
            n++;
    }
    n++;
    n = n * 2 - 1; //Затем значение n умножается на 2 и вычитается 1, чтобы вычислить общее количество элементов в массиве res.
//После создания массива происходит заполнение его элементами из символьного массива s
    Lexem** res = new Lexem * [n];
    int start = 0;
    int j = 0;
    for (int i = 0; i < l; i++) //обхода символьного массива s
        //Переменная l содержит длину массива s. Внутри цикла происходит проверка,
        //является ли символ в позиции i цифрой с помощью функции isdigit. Если символ не является цифрой,
        //происходит проверка наличия открывающей скобки или генерация исключения
    {
        if (isdigit(s[i]) == 0) //Если i равно 0, то проверяется, является ли символ открывающей скобкой.
            //Если да, создается новый объект класса TBracketOpen, который добавляется к массиву res в позицию j. 
            //Если это не открывающая скобка, генерируется исключение (throw -1) - скорее всего, это сигнализирует о синтаксической ошибке.
        {
            if (i == 0)
            {
                if (s[i] == '(')
                    res[j] = new TBracketOpen('(');
                else //После этого увеличивается значение j, чтобы указать на следующую позицию в массиве res,
                    //и переменная start устанавливается в 1
                    throw - 1;
                j++;
                start = 1;
            }
            else { //проверяет символы в строке s и выполняет определенные операции в зависимости от типа символа.
                //Если предыдущий символ является числовым, то символы помещаются в массив ch и добавляются как новый TNum в массив res. 
                //Если текущий символ не является числом, то используется оператор switch для определения типа символа и добавляется соответствующий объект TPlus, TSub, TMultiplication, TDivision, TBracketOpen или TBracketClose в массив res.
                //Затем переменная start устанавливается равной i + 1 для следующей итерации.
                if (isdigit(s[i - 1]) != 0)
                {
                    char ch[256];
                    int l2 = i - start + 1;

                    for (int k = 0; k < l2 - 1; k++)
                        ch[k] = s[start + k];

                    ch[l2 - 1] = 0;
                    res[j] = new TNum(ch);
                    j++;
                }
                if (isdigit(s[i]) == false) {
                    switch (s[i])
                    {
                    case '+':res[j] = new TPlus('+'); break;
                    case '-':res[j] = new TSub('-'); break;
                    case '*':res[j] = new TMultiplication('*'); break;
                    case '/':res[j] = new TDivision('/'); break;
                    case '(':res[j] = new TBracketOpen('('); break;
                    case ')':res[j] = new TBracketClose(')'); break;
                    }
                    j++;
                    start = i + 1;
                }
            }
        }
    }
    int l2 = l - start + 1; //собирает все символы, которые представляют число, в массив ch и преобразует их в объект TNum, который затем добавляется в массив res.

//Переменная l2 вычисляет длину текущего числового значения символов, начиная с позиции start.
//Массив ch выделяет память на 256 символов для хранения символов числового значения. 
    char ch[256];
    if (l2 > 1) //Если длина l2 больше 1, цикл for копирует символы значения в массив ch.

Затем создается объект TNum, используя массив ch, и добавляется в массив res. 
    {
        for (int k = 0; k < l2 - 1; k++)
            ch[k] = s[start + k];

        ch[l2 - 1] = 0;
        res[j] = new TNum(ch);
        j++;
    }
    n = j; // //Переменная n устанавливается равной j. Создается новый массив opers, который заполняется ссылками на объекты в массиве res, и массив res удаляется.

    opers = new Lexem * [n];
    for (int i = 0; i < n; i++)
        opers[i] = res[i];
    delete[] res;
}

int TPolish::Calculation(char* s) //вычисление выражения, записанного в обратной польской нотации. 
//Сначала происходит создание лексем и связывание операндов, затем создается массив результата, инициализируется стек.
//Затем в цикле происходит проверка приоритета операции, и если он равен -1, то лексема добавляется в массив результата. 
//Если приоритет операции равен 1, то операция добавляется в стек. 
//Если же приоритет операции равен 0, то из стека извлекается операция, пока ее приоритет не станет равен 1, и все операции добавляются в массив результата.
//В конце алгоритма, когда все операции были обработаны и добавлены в массив результата, происходит вычисление выражения
{
    int n = 0;
    Lexem** operands = 0;
    TOperFactory::create(s, n, operands);
    Lexem** res = new Lexem * [n];
    TStack<Lexem*> stack(n);
    int j = 0;
    for (int i = 0; i < n; i++) {
        if (operands[i]->prioritet() == -1) {
            res[j] = operands[i];
            j++;
        }
        else {
            if (stack.isEmpty() || operands[i]->prioritet() == 1)
                stack.push(operands[i]);
            else if (operands[i]->prioritet() == 0)
            {
                Lexem* tmp = stack.get();
                while (tmp->prioritet() != 1) {
                    res[j] = tmp;
                    j++;
                    tmp = stack.get();
                }
            }
            else { //читать входную строку слева направо, и если это операнд (число или переменная), то добавлять его в выходную строку.
                //Если это оператор, то помещать его в стек. Если находится открывающая скобка, то помещать ее в стек. 
                //Если находится закрывающая скобка, то выталкивать операторы из стека до тех пор, пока не встретится открывающая скобка.

//Если текущий оператор имеет более высокий приоритет, чем оператор, находящийся наверху стека, то он помещается в стек.
                //Если текущий оператор имеет более низкий или равный приоритет, чем оператор, находящийся наверху стека, то операторы из стека выталкиваются в выходную строку, пока не встретится оператор с более низким приоритетом.
                //Затем текущий оператор помещается в стек.

//В итоге, после обработки всей входной строки, все оставшиеся операторы из стека выталкиваются в выходную строку.
                Lexem* top = stack.get();
                if (operands[i]->prioritet() > top->prioritet())
                {
                    stack.push(top);
                    stack.push(operands[i]);
                }
                else
                {
                    while (operands[i]->prioritet() <= top->prioritet())
                    {
                        res[j] = top;
                        j++;
                        if (stack.isEmpty())
                            break;
                        top = stack.get();
                    }
                    if (!stack.isEmpty())
                        stack.push(top);
                    stack.push(operands[i]);
                }
            }
        }
    }
    while (!stack.isEmpty()) //Пока стек не пустой, извлекается элемент из стека и помещается в массив res.
//Создается новый стек ns.
//Для каждого элемента в массиве res выполняется следующее:
//Если элемент res[i] имеет приоритет -1, он помещается в стек ns.
//В противном случае извлекаются два элемента b и a из стека ns. Затем выполняется операция res[i]->Calc(a, b) и результат помещается в стек ns.
//Извлекается элемент r из стека ns.
//Освобождаются память, выделенная для массивов operands и res.
//Возвращается значение, полученное из элемента r.
//Этот код представляет собой реализацию вычисления выражения, представленного в виде обратной польской записи.
    {
        Lexem* tmp = stack.get();
        res[j] = tmp;
        j++;
    }
    TStack<Lexem*> ns(n);
    for (int i = 0; i < j; i++)
    {
        if (res[i]->prioritet() == -1)
            ns.push(res[i]);
        else
        {
            Lexem* b = ns.get();
            Lexem* a = ns.get();
            Lexem* c = res[i]->Calc(a, b);
            ns.push(c);
        }
    }
    Lexem* r = ns.get();
    delete[] operands;
    delete[] res;
    return r->getNumber();
}

